05-211008 加藤大地

工夫した点

・評価関数を場面によって分割したこと

ゲーム中，AIは3種類の評価関数を何手目かによって使い分けるように設計した。序盤・中盤においては，EVAL_NORMALを利用した。EVAL_NORMALは，ウイングの個数，相手に角を取られやすくなるC打ち，X打ちの数，擬似確定石（4隅とそれに連接する石の数），着手可能手数，開放度をそれぞれ計算し，これらに重みをかけて合計したものを評価値とする関数である。終盤については，基本的にはEVAL_PERFECTにより盤面を評価した。これは，自分の石の数から相手の石の数を引いたものをそのまま評価値とする評価関数である。ただ，EVAL_PERFECTで完全読みをする前に，1ターン分EVAL_WINを用いて，勝つか負けるかだけを完全に探索しおえる評価関数を作った。この関数は，勝つ，引き分け，負けという評価値しかもたないため，alpha-beta法を用いて探索すると，カットが多数生まれ，そこそこ深いところまで探索することができるため，完全読みでは読みきれない部分を読み切るのに利用した。

・ビットボードを用いた

盤面をビットボードを用いることで実装した。これにより，計算時間の減少，オーバーヘッドを小さくすることなどに成功した。具体的には，中盤の評価関数で8手先まで，終盤のEVAL_WINでは18手先まで読み切ることができるようになった（盤面によっては19,20手先まで読み切ることもできていたが，1分という持ち時間の中では安定して処理できていなかったため，18手にとどめた）。

・alphabetaを利用（厳密にはnegamaxを利用）

探索のアルゴリズムには，alpha-beta法を用いた。上でも述べたように，EVAL_WINを用いて評価する際に，カットが大きな効果をもたらした。これにより勝率が大きく向上した。

・残り時間に合わせて評価を打ち切り

CPUの状態や盤面の状況によっては，評価がうまく進まず，持ち時間ギリギリになってしまうことがあった。そのため，残り時間が10秒を切ったときに，EVAL_WINやEVAL_PERFECT等を用いた深い探索がまだ継続されていた場合は，評価を打ち切り，EVAL_NORMALに評価関数を入れ替えて再び計算・探索をやり直す，という処理をするようにした。また，残り時間が1s以下になった時は，合法手のなかから適当に一手を選ぶように設計した。

・マルチスレッドによる実装

マルチコアの恩恵を十分に受けるべく，最初はシングルスレッドで実装していたものを，マルチスレッドに実装し直した。（この部分が今回の課題で一番大変でした。。バグを潰すのに丸一日かかってしまいました）基本的には，シングルスレッドでの実装より数段早い速度で計算が進むようになった。ただ，CPUの状態によっては，例えば他に重いアプリを起動していたりすると，シングルスレッドで実装したときより性能が劣ってしまうこともあった。

・勝敗予測

おまけ的な機能として，必勝読み，完全読みをする際に，勝敗予想をつけるように実装した。最初は単なる遊び心でつけたものだったが，これを実装したことにより探索にバグがあることが発見できたので，結果的に本質的な役割を果たしてくれた。デバッグがやりやすくなった，という点でも有用だった。


もっと工夫できたかもしれない点

・定石

オセロには多数の定石が存在していて，それをはずした手を打つとほぼ凡手，悪手になってしまうと言われているらしい。ただ，時間の都合上，定石を用いた手の決定まで実装が間に合わなかった。また，中盤の評価関数と競合してしまう可能性もあると考えたため，今回は実装しなかった。


周りの人に対戦してもらったときの感想

・隅を取ろうとしても取れない

確定石にかなり大きめの正の重みをつけているため，このような感想が生まれたと考えている。

・計算がはやい

以前pythonを用いてオセロのAIを遊びで実装したことがあり，同一人物に遊んでもらっていたのだが，それに比べての発言だった。かなり昔に作ったものなので，深さや実装の仕方もだいぶ異なっているため，単純比較できることではないかもしれないが，インタプリタ言語とコンパイル言語でこれほどまで差がでるのか，と実感できるいい機会になった。

・隅をとれるのにとらないことにイライラした

AIが隅を取れる手番なのに，角をとらないで違う場所に着手したことに対する感想。人と遊びで対戦する際では，角が取れるようになったらすぐとりたくなってしまうものだが，AIはある決まった深さに対して探索を行い，その深さのところで最終的に角が取れれば評価値が変わらないので，このような着手の仕方をしたと考えられる。

・おける場所が少なくなっていくのを実感した

着手可能手数にも大きめの重みをつけているため，このような感想が生まれたと考えられる。


ビルド・実行方法

cargo build --release
により，target/releaseにreversiという実行ファイルが生成されるので，それを実行すればよい。
実行時，引数として，-Hでhost名，-pでport名，-nで自分の名前を設定できる。デフォルト値は，
host = "localhost"
port = "3000"
name = "Player"
である。


参考

・「オセロをビットボードで実装する」 https://qiita.com/sensuikan1973/items/459b3e11d91f3cb37e43


感想

オセロAIを実装するにあたり，最も重要なことは計算速度であると考えていたため，今まで全く利用したことがなかったRUSTを，この機会に利用してみようと考え，一から勉強してRUSTを用いて実装した。RUSTは安全性・速度・並行性によく優れていると言われているが，もっとも苦労したのは，その速度をだすために欠かせない「所有権」の概念であった。大変ではあったが，そこそこ強いAIができたので満足している。（オセロがそもそもあまり得意ではないというのもありますが，自分は100パーセント負けるようになりました。自分の子供に身長を抜かされたときのような気分を味わいました。）RUSTの仕様についてまだよくわかっていないところも多々あるので，これをきっかけにRUSTをいろいろといじってみようと思う。